{
  "version": 3,
  "sources": ["../../shamirs-secret-sharing/constants.js", "../../shamirs-secret-sharing/buffer.js", "../../shamirs-secret-sharing/table.js", "../../shamirs-secret-sharing/codec.js", "../../shamirs-secret-sharing/combine.js", "../../shamirs-secret-sharing/split.js", "../../shamirs-secret-sharing/index.js"],
  "sourcesContent": ["export const PRIMITIVE_POLYNOMIAL = 29\n\nexport const BIT_PADDING = 128\nexport const BIT_COUNT = 8\nexport const BIT_SIZE = 2 ** BIT_COUNT\n\nexport const BYTES_PER_CHARACTER = 2\nexport const MAX_BYTES_PER_CHARACTER = 6\n\nexport const MAX_SHARES = BIT_SIZE - 1\n\nexport const UTF8_ENCODING = 'utf8'\nexport const BIN_ENCODING = 'binary'\nexport const HEX_ENCODING = 'hex'\n\nexport default {\n  PRIMITIVE_POLYNOMIAL,\n\n  BIT_PADDING,\n  BIT_COUNT,\n  BIT_SIZE,\n\n  MAX_SHARES,\n\n  MAX_BYTES_PER_CHARACTER,\n  BYTES_PER_CHARACTER,\n\n  UTF8_ENCODING,\n  BIN_ENCODING,\n  HEX_ENCODING,\n}\n", "/**\n * TypedArray\n * @typedef {Int8Array|Int16Array|Int32Array|BigInt64Array|Uint8Array|Uint16Array|Uint32Array|BigUint64Array|Float32Array|Float64Array} TypedArray\n */\n\n/**\n * ArrayLike\n * @typedef {Array|{ length: number }} ArrayLike\n */\n\n/**\n * BufferLike\n * @typedef {TypedArray|ArrayBuffer|ArrayLike} BufferLike\n */\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nconst ALPHA16_CHARS = '0123456789abcdef'\nconst ALPHA16_ARRAY_TABLE = new Array(256)\n\nfor (let i = 0; i < 16; ++i) {\n  const i16 = i * 16\n  for (let j = 0; j < 16; ++j) {\n    ALPHA16_ARRAY_TABLE[i16 + j] = ALPHA16_CHARS[i] + ALPHA16_CHARS[j]\n  }\n}\n\n\n// lifted from Socket Runtime\nconst RANDOM_BYTES_QUOTA = 64 * 1024\n\n/**\n * The set of all known prototypes of `TypedArray` descendants.\n * @type {Set<object>}\n */\nexport const TypedArrayPrototypeSet = new Set([\n  Int8Array.prototype,\n  Int16Array.prototype,\n  Int32Array.prototype,\n  BigInt64Array.prototype,\n  Uint8Array.prototype,\n  Uint16Array.prototype,\n  Uint32Array.prototype,\n  BigUint64Array.prototype,\n  Float32Array.prototype,\n  Float64Array.prototype\n])\n\n/**\n * Allocates a `Uint8Array` of size `byteLength` bytes.\n * @param {number} byteLength\n * @return {Uint8Array}\n */\nexport function alloc (byteLength) {\n  if (byteLength < 0 || !Number.isFinite(byteLength) || !Number.isSafeInteger(byteLength)) {\n    throw new RangeError(\n      `The argument 'byteLength' is invalid: Received ${byteLength}`\n    )\n  }\n\n  return new Buffer(byteLength)\n}\n\n/**\n * Predicate function to determine if `input` is a \"buffer like\"\n * object:\n * - an `ArrayBuffer` or `ArrayBuffer` ancestor\n * - an `ArrayBuffer` \"view\" (exlcluding `DataView`)\n * - an `Array` or `Array` ancestor\n * - an \"arra like\" object, something with `length`\n * @param {any} input\n * @return {boolean}\n */\nexport function isBufferLike (input) {\n  if (!input) {\n    return false\n  }\n\n  return (\n    input instanceof ArrayBuffer ||\n    ArrayBuffer.isView(input) ||\n    Array.isArray(input) ||\n    (\n      typeof input === 'object' &&\n      'length' in input &&\n      typeof input.length === 'number'\n    )\n  )\n}\n\n/**\n * Predicate function to determine if `input` is a `TypedArray`.\n * @param {any} input\n * @param {?Function} [TypedArray]\n * @return {boolean}\n */\nexport function isTypedArray (input, TypedArray = null) {\n  if (!isBufferLike(input)) {\n    return false\n  }\n\n  // narrow check\n  if (typeof TypedArray === 'function') {\n    if (TypedArrayPrototypeSet.has(TypedArray.prototype)) {\n      const prototype = Object.getPrototypeOf(input)\n      return (\n        prototype === TypedArray.prototype ||\n        TypedArray.prototype.isPrototypeOf(prototype)\n      )\n    }\n  }\n\n  const prototype = Object.getPrototypeOf(input)\n  for (const TypedArrayPrototype of TypedArrayPrototypeSet) {\n    if (\n      TypedArrayPrototype === prototype ||\n      TypedArrayPrototype.isPrototypeOf(prototype)\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Predicate function to determine if `input` is an `ArrayBuffer`.\n * @param {any} input\n * @return {boolean}\n */\nexport function isArrayBuffer (input) {\n  if (!input) {\n    return false\n  }\n\n  const TypeClass = /** @type {object} */ (input).constructor\n  return (\n    TypeClass === ArrayBuffer ||\n    ArrayBuffer.prototype.isPrototypeOf(Object.getPrototypeOf(input))\n  )\n}\n\n/**\n * Computes byte length for \"buffer like\" or string `input`.\n * @param {BufferLike|string} input\n * @param {string} [encoding]\n * @return {number}\n */\nexport function getByteLength (input, encoding = 'utf8') {\n  if (typeof input === 'string') {\n    if (encoding === 'hex') {\n      return input.length >>> 1\n    } else if (encoding === 'utf8') {\n      return textEncoder.encode(input).byteLength\n    } else {\n      return input.length\n    }\n  }\n\n  if (!isBufferLike(input)) {\n    return 0\n  }\n\n  if ('byteLength' in /** @type {BufferLike} */ (input)) {\n    return input.byteLength\n  }\n\n  // verify that elements in such `input` are safe finite integers\n  if ('length' in input) {\n    for (const element of /** @type {Array} */ (input)) {\n      if (\n        !Number.isFinite(element) ||\n        !Number.isInteger(element) ||\n        !Number.isSafeInteger(element)\n      ) {\n        return 0\n      }\n    }\n\n    return input.length\n  }\n\n  return 0\n}\n\n/**\n * Computes and returns `ArrayBuffer` for a given `input`. If `input` is\n * an `ArrayBuffer`, then it is returned. If an `ArrayBuffer` cannot be\n * determined, then `null` is returned\n * @param {any} input\n * @return {?ArrayBuffer}\n */\nexport function getArrayBuffer (input) {\n  if (!isBufferLike(input)) {\n    return null\n  }\n\n  if (isArrayBuffer(input)) {\n    return input\n  }\n\n  if (isTypedArray(/** @type {TypedArray} */ (input))) {\n    return /** @type {TypedArray} */ (input).buffer\n  }\n\n  if (isArrayBuffer(input.buffer)) {\n    return /** @type {ArrayBuffer} */ (input.buffer)\n  }\n\n  return null\n}\n\n/**\n * Concat an arbitrary number of \"buffer like\" objects into a single\n * instance. Inputs must be \"buffer like\" and the final instance returned\n * is determined by the first object class constructor. If invalid input is\n * given, then `null` is returned.\n * @param {...BufferLike|Array} args\n */\nexport function concat (...args) {\n  if (args.length === 0) {\n    return null\n  }\n\n  if (args.length === 1 && Array.isArray(args[0])) {\n    return concat(...args[0])\n  }\n\n  for (const arg of args) {\n    if (!isBufferLike(arg)) {\n      return null\n    }\n  }\n\n  /**\n   * @type {?Uint8Array}\n   */\n  let view\n\n  /**\n   * @type {BufferLike}\n   */\n  let buffer\n\n  /**\n   * @type {?BufferLike | undefined}\n   */\n  const first = args.shift()\n\n  if (first === undefined || first === null) {\n    return null\n  }\n\n  /**\n   * @type {Function}\n   */\n  const TypeClass = first.constructor\n\n  /**\n   * @type {number}\n   */\n  const totalSize = [first]\n    .concat(args)\n    .map((arg) => getByteLength(arg))\n    .reduce((a, b) => a + b, 0)\n\n  if ( // handle `ArrayBuffer` or `ArrayBuffer` ancestor\n    TypeClass === ArrayBuffer ||\n    ArrayBuffer.prototype.isPrototypeOf(Object.getPrototypeOf(first))\n  ) {\n    buffer = new /** @type {typeof ArrayBuffer} */ (TypeClass)(totalSize)\n    // validate that we created a new `ArrayBuffer` or `ArrayBuffer` ancestor\n    // that provides the correct `byteLength` accessor value\n    if (buffer.byteLength !== totalSize) {\n      throw new TypeError('Unable to correctly allocate output buffer')\n    }\n\n    view = new Uint8Array(buffer)\n  } else if ( // handle `Array` or `Array` ancestor\n    TypeClass === Array ||\n    Array.isArray(first) ||\n    Array.prototype.isPrototypeOf(Object.getPrototypeOf(first))\n  ) {\n    buffer = new /** @type {typeof Array} */ (TypeClass)(totalSize)\n    // ensure computed byte length is equivalent to the computed total size\n    if (getByteLength(buffer) !== totalSize) {\n      throw new TypeError('Unable to correctly allocate output buffer')\n    }\n\n    const arrayBuffer = getArrayBuffer(buffer)\n    view = isArrayBuffer(arrayBuffer)\n      ? new Uint8Array(/** @type {ArrayBuffer} */ (arrayBuffer))\n      : Uint8Array.from(buffer)\n  } else if ( // handle `TypedArray` descendants\n    isTypedArray(first)\n  ) {\n    buffer = /** @type {TypedArray} */ (\n      new /** @type {{ new (number) }} */ (TypeClass)(totalSize)\n    )\n    // validate that we created a new `TypedArray` or `TypedArray` ancestor\n    // that provides the correct `byteLength` accessor value\n    if (/** @type {TypedArray} */ (buffer).byteLength !== totalSize) {\n      throw new TypeError('Unable to correctly allocate output buffer')\n    }\n\n    const arrayBuffer = getArrayBuffer(buffer)\n    view = new Uint8Array(/** @type {ArrayBuffer} */ (arrayBuffer))\n  } else { // must be \"array\" like in some way\n    buffer = new /** @type {typeof Array} */ (TypeClass)(totalSize)\n    // ensure computed byte length is equivalent to the computed total size\n    if (getByteLength(buffer) !== totalSize) {\n      throw new TypeError('Unable to correctly allocate output buffer')\n    }\n\n    const arrayBuffer = getArrayBuffer(buffer)\n    view = isArrayBuffer(arrayBuffer)\n      ? new Uint8Array(/** @type {ArrayBuffer} */ (arrayBuffer))\n      : Uint8Array.from(buffer)\n  }\n\n  const buffers = [first].concat(args)\n  let offset = 0\n\n  while (buffers.length) {\n    const arrayBuffer = getArrayBuffer(buffers.shift())\n\n    if (!arrayBuffer) {\n      throw new TypeError('Unable to determine ArrayBuffer in arguments')\n    }\n\n    const array = new Uint8Array(arrayBuffer)\n    view.set(array, offset)\n    offset += array.byteLength\n  }\n\n  return buffer\n}\n\n/**\n * Creates a \"buffer\" (`Uint8Array`) from `input`\n * @param {BufferLike|string} input\n * @param {number} [byteOffset]\n * @param {number} [byteLength]\n * @param {string} [encoding = 'utf8']\n * @return {Buffer}\n */\nexport function create (\n  input,\n  byteOffset = input.byteOffset || 0,\n  byteLength = getByteLength(input),\n  encoding = 'utf8'\n) {\n  if (typeof input === 'string') {\n    if (encoding === 'hex') {\n      byteLength = getByteLength(input, 'hex')\n      const buffer = new Buffer(byteLength)\n\n      for (let i = 0; i < input.length; ++i) {\n        const offset = 2 * i\n        const byte = parseInt(input.slice(offset, offset + 2), 16)\n\n        if (Number.isNaN(byte)) {\n          break\n        }\n\n        buffer[i] = byte\n      }\n\n      return buffer\n    }\n\n    if (encoding === 'base64') {\n      const string = globalThis.atob(input)\n      const buffer = new Buffer(string.length)\n      for (let i = 0; i < string.length; ++i) {\n        buffer[i] = string.charCodeAt(i)\n      }\n\n      return buffer\n    }\n\n    return create(textEncoder.encode(input))\n  }\n\n  if (isBufferLike(input)) {\n    const arrayBuffer = getArrayBuffer(input)\n    if (isArrayBuffer(arrayBuffer)) {\n      return new Buffer(\n        /** @type {ArrayBuffer} */ (arrayBuffer),\n        input.byteOffset || byteOffset,\n        byteLength\n      )\n    }\n  }\n\n  if (Array.isArray(input)) {\n    return new Buffer(input)\n  }\n\n  return new Buffer(0)\n}\n\n/**\n * Creates `Uint8Array` buffer from a variety of input.\n * @param {BufferLike|string} input\n * @param {number|string} [byteOffset]\n * @param {number} [byteLength]\n * @param {string} [encoding = 'utf8']\n * @return {Buffer}\n */\nexport function from (input, byteOffset, byteLength, encoding = 'utf8') {\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    return create(input, 0, getByteLength(input), encoding)\n  }\n\n  return create(input, byteOffset || 0, byteLength || getByteLength(input), encoding)\n}\n\n/**\n * Compares two `a` and `b` buffers.\n * @param {BufferLike|string} a\n * @param {BufferLike|string} b\n * @param {string} [encoding]\n * @return {-1 | 0 | 1}\n */\nexport function compare (a, b, encoding = 'utf8') {\n  if (\n    a instanceof Uint8Array ||\n    Uint8Array.prototype.isPrototypeOf(Object.getPrototypeOf(a))\n  ) {\n    a = from(\n      a,\n      /** @type {Uint8Array} */ (a).byteOffset,\n      /** @type {Uint8Array} */ (a).byteLength\n    )\n  }\n\n  if (\n    b instanceof Uint8Array ||\n    Uint8Array.prototype.isPrototypeOf(Object.getPrototypeOf(b))\n  ) {\n    b = from(\n      b,\n      /** @type {Uint8Array} */ (b).byteOffset,\n      /** @type {Uint8Array} */ (b).byteLength\n    )\n  }\n\n  if (typeof a === 'string') {\n    a = from(a, encoding)\n  }\n\n  if (typeof b === 'string') {\n    b = from(b, encoding)\n  }\n\n  if (!isBufferLike(a) || !isBufferLike(b)) {\n    throw new TypeError(\n      'Input buffers must be \"buffer like\"'\n    )\n  }\n\n  if (a === b) {\n    return 0\n  }\n\n  if (isArrayBuffer(a)) {\n    a = from(a)\n  }\n\n  if (isArrayBuffer(b)) {\n    b = from(b)\n  }\n\n  let x = /** @type {Uint8Array} */ (a).byteLength\n  let y = /** @type {Uint8Array} */ (b).byteLength\n\n  for (let i = 0, length = Math.min(x, y); i < length; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) {\n    return -1\n  } else if (y < x) {\n    return 1\n  }\n\n  return 0\n}\n\n/**\n * Converts a \"buffer like\" object to a string.\n * @param {BufferLike} input\n * @param {string} [encoding = 'utf8']\n * @return {string}\n */\nexport function toString (input, encoding = 'utf8') {\n  const buffer = from(input)\n\n  if (encoding === 'hex') {\n    const output = []\n\n    for (let i = 0; i < buffer.byteLength; ++i) {\n      output.push(ALPHA16_ARRAY_TABLE[buffer[i]])\n    }\n\n    return output.join('')\n  }\n\n  if (encoding === 'base64') {\n    const output = []\n\n    for (let i = 0; i < buffer.byteLength; ++i) {\n      output.push(String.fromCharCode(buffer[i]))\n    }\n\n    return globalThis.btoa(output.join(''))\n  }\n\n  return textDecoder.decode(buffer)\n}\n\n/**\n * Generates random bytes of `size` bytes.\n * @param {number} byteLength\n * @return {Buffer}\n */\nexport function randomBytes (byteLength) {\n  const buffers = []\n\n  if (typeof globalThis.crypto?.getRandomValues !== 'function') {\n    throw new TypeError(\n      'Missing globalThis.crypto.getRandomValues implementation'\n    )\n  }\n\n  if (byteLength <= 0 || !Number.isFinite(byteLength) || !Number.isSafeInteger(byteLength)) {\n    throw new RangeError(\n      `The argument 'byteLength' is invalid: Received ${byteLength}`\n    )\n  }\n\n  let byteLengthRemaining = byteLength\n\n  do {\n    // clamp `byteLengthRemaining`\n    const byteLength = byteLengthRemaining > RANDOM_BYTES_QUOTA\n      ? RANDOM_BYTES_QUOTA\n      : byteLengthRemaining\n\n    const bytes = globalThis.crypto.getRandomValues(new Int8Array(byteLength))\n    const buffer = Buffer.from(bytes)\n    // @ts-ignore\n    buffers.push(buffer)\n    byteLengthRemaining = Math.max(0, byteLengthRemaining - RANDOM_BYTES_QUOTA)\n  } while (byteLengthRemaining > 0)\n\n  return Buffer.concat(buffers)\n}\n\n/**\n * A simple `Buffer` class based on an `Uint8Array` used\n * within this module. It is similar to the Node.js and Socket Runtime\n * `Buffer` class.\n */\n// @ts-ignore\nexport class Buffer extends Uint8Array {\n  static alloc = alloc\n  static byteLength = getByteLength\n  static compare = compare\n  static concat = concat\n\n  static from = from\n  static isBufferLike = isBufferLike\n  static random = randomBytes\n\n  static get Buffer () {\n    return Buffer\n  }\n\n  /**\n   * Predicate function to deterine if `input` is a `Buffer`\n   * @param {any} input\n   * @return {boolean}\n   */\n  static isBuffer (input) {\n    return isTypedArray(input, this) || isTypedArray(input, Uint8Array)\n  }\n\n  /**\n   * Computed byte length\n   * @type {number}\n   */\n  get length () {\n    return this.byteLength\n  }\n\n  /**\n   * Converts this `Buffer` instance to a string with an optional\n   * encoding\n   * @param {string} [encoding]\n   */\n  toString (encoding = 'utf8') {\n    return toString(this, encoding)\n  }\n\n  /**\n   * Converts this `Buffer` class to a JSON object.\n   */\n  toJSON () {\n    return {\n      type: 'Buffer',\n      data: Array.from(this)\n    }\n  }\n}\n\nTypedArrayPrototypeSet.add(Buffer.prototype)\n\nexport default Buffer\n", "import { PRIMITIVE_POLYNOMIAL, MAX_SHARES, BIT_SIZE, } from './constants.js'\n\nexport const zeroes = new Array(4 * BIT_SIZE).join('0')\nexport const logs = new Array(BIT_SIZE).fill(0)\nexport const exps = new Array(BIT_SIZE).fill(0)\n\nfor (let i = 0, x = 1; i < BIT_SIZE; ++i) {\n  exps[i] = x\n  logs[x] = i\n  x = x << 1\n  if (x >= BIT_SIZE) {\n    x = x ^ PRIMITIVE_POLYNOMIAL\n    x = x & MAX_SHARES\n  }\n}\n\nexport default {\n  exps,\n  logs,\n  zeroes\n}\n", "import { Buffer, isBufferLike } from './buffer.js'\nimport { zeroes } from './table.js'\n\nimport {\n  BYTES_PER_CHARACTER,\n  UTF8_ENCODING,\n  BIN_ENCODING,\n  BIT_COUNT,\n  BIT_SIZE,\n} from './constants.js'\n\n/**\n * @typedef {import('./buffer.js').BufferLike} BufferLike\n */\n\n/**\n * Pads an input `string` with `multiple` zeroes. If `multiple` is not given,\n * then `constants.BIT_COUNT` is used by default.\n * @param {string|BufferLike} input\n * @param {number} [multiple]\n * @return {string}\n */\nexport function pad (input, multiple = BIT_COUNT) {\n  const string = Buffer.from(input).toString()\n\n  if (multiple === 0) {\n    return string\n  } else if (!multiple) {\n    multiple = BIT_COUNT\n  }\n\n  const missing = string\n    ? string.length % multiple\n    : 0\n\n  if (missing) {\n    const offset = -1 * ((multiple - missing) + string.length)\n    return (zeroes + string).slice(offset)\n  }\n\n  return string\n}\n\n/**\n * Encodes input string or TypedArray as a hex string.\n * @param {string|BufferLike} input\n * @param {string} [encoding]\n * @return {string}\n */\nexport function hex (input, encoding = UTF8_ENCODING) {\n  const padding = 2 * BYTES_PER_CHARACTER\n\n  if (!encoding) {\n    encoding = UTF8_ENCODING\n  }\n\n  if (typeof input === 'string') {\n    return fromString(/** @type {string} */ (input))\n  }\n\n  if (isBufferLike(input)) {\n    return fromBuffer(Buffer.from(/** @type {BufferLike} */ (input)))\n  }\n\n  throw new TypeError('Expecting a string or buffer as input.')\n\n  function fromString (string) {\n    const chunks = /** @type {string[]} */ ([])\n\n    if (UTF8_ENCODING === encoding) {\n      for (let i = 0; i < /** @type {string} */ (string).length; ++i) {\n        const chunk = String.fromCharCode(string[i].toString(16))\n        const padded = pad(chunk, padding)\n        // @ts-ignore\n        chunks.unshift(padded)\n      }\n    }\n\n    if (BIN_ENCODING === encoding) {\n      string = pad(input, 4)\n\n      for (let i = string.length; i >= 4; i -= 4) {\n        const bits = string.slice(i - 4, i)\n        const chunk = parseInt(bits, 2).toString(16)\n        // @ts-ignore\n        chunks.unshift(chunk)\n      }\n    }\n\n    return chunks.join('')\n  }\n\n  function fromBuffer (buffer) {\n    const chunks = []\n\n    for (let i = 0; i < buffer.length; ++i) {\n      const chunk = buffer[i].toString(16)\n      const padded = pad(chunk, padding)\n      // @ts-ignore\n      chunks.unshift(padded)\n    }\n\n    return chunks.join('')\n  }\n}\n\n/**\n * Encodes `input` as a binary string. An optional `radix` value that defaults\n * to `16` can be used to indicate the chunk type in an `input` string.\n * @param {string|BufferLike} input\n * @param {number} [radix = 16]\n * @return {string}\n */\nexport function bin (input, radix = 16) {\n  const chunks = []\n\n  if (!radix) {\n    radix = 16\n  }\n\n  const byteLength = Buffer.byteLength(input)\n\n  for (let i = byteLength - 1; i >= 0; --i) {\n    let chunk\n\n    if (isBufferLike(input)) {\n      chunk = input[i]\n    }\n\n    if (typeof input === 'string') {\n      chunk = parseInt(input[i], radix)\n    }\n\n    if (Array.isArray(input)) {\n      chunk = input[i]\n\n      if (typeof chunk === 'string') {\n        chunk = parseInt(chunk, radix)\n      }\n    }\n\n    if (chunk === undefined) {\n      throw new TypeError('Unsupported type for chunk in input.')\n    }\n\n    const padded = pad(chunk.toString(2), 4)\n    // @ts-ignore\n    chunks.unshift(padded)\n  }\n\n  return chunks.join('')\n}\n\n/**\n * Encodes input `id` and `data` vector as a `Buffer`\n * @param {string|number|BufferLike} id\n * @param {string|BufferLike} data\n * @return {Buffer}\n */\nexport function encode (id, data) {\n  id = typeof id === 'number'\n    ? id\n    : /** @type {number} */ (parseInt(Buffer.from(id).toString(), 16))\n\n  const padding = (BIT_SIZE - 1).toString(16).length\n  const header = Buffer.concat([\n    // `BIT_COUNT` is stored as a base36 value, which in this case is the literal '8'\n    Buffer.from(BIT_COUNT.toString(36).toUpperCase()), // 8\n    Buffer.from(pad(id.toString(16), padding))\n  ])\n\n  if (!isBufferLike(data)) {\n    data = Buffer.from(data)\n  }\n\n  return Buffer.concat([header, data])\n}\n\n/**\n * Decodes `input` previously encoded with `encoded` and returns the\n * `data` part\n * @param {string|BufferLike} input\n * @param {string} [encoding = 'utf8']\n * @return {Buffer}\n */\nexport function decode (input, encoding = 'utf8') {\n  const padding = 2 * BYTES_PER_CHARACTER\n  const string = pad(Buffer.from(input).toString(encoding), padding)\n  const offset = padding\n  const chunks = []\n\n  for (let i = 0; i < string.length; i += offset) {\n    const bits = string.slice(i, i + offset)\n    const chunk = parseInt(bits, 16)\n    // @ts-ignore\n    chunks.unshift(chunk)\n  }\n\n  return Buffer.from(chunks)\n}\n\n/**\n * Splits an `input` into paged byte chunks where an optional `padding`\n * is applied. Chunks are parsed integers of `radix` (default: 2).\n * @param {string|BufferLike} input\n * @param {number} [padding = 0]\n * @param {number} [radix = 2]\n * @return {number[]}\n */\nexport function split (input, padding = 0, radix = 2) {\n  const chunks = []\n  const string = pad(Buffer.from(input).toString(), padding)\n  let i = 0\n\n  for (i = string.length; i > BIT_COUNT; i -= BIT_COUNT) {\n    const bits = string.slice(i  - BIT_COUNT, i)\n    const chunk = parseInt(bits, radix)\n    // @ts-ignore\n    chunks.push(chunk)\n  }\n\n  // @ts-ignore\n  chunks.push(parseInt(string.slice(0, i), radix))\n\n  return chunks\n}\n\nexport default {\n  bin,\n  decode,\n  encode,\n  hex,\n  pad,\n  split\n}\n", "import { BIN_ENCODING, BIT_SIZE, MAX_SHARES } from './constants.js'\nimport { Buffer, isBufferLike } from './buffer.js'\nimport { logs, exps } from './table.js'\nimport codec from './codec.js'\n\nexport const MAX_BITS = BIT_SIZE - 1\n\n/**\n * @typedef {{ id?: number, bits?: number, data?: string }} ShareData\n * @typedef {import('./buffer.js').BufferLike} BufferLike\n */\n\nexport class Share {\n  id = 0\n  bits = 0\n  data = ''\n\n  /**\n   * Creates a `Share` object from a variety of input\n   * @param {ShareData|number|string} [id]\n   * @param {?number} [bits = 0]\n   * @param {?string} [data = null]\n   */\n  static from (id = 0, bits = 0, data = null) {\n    if (id !== null && typeof id === 'object') {\n      const share = /** @type {ShareData} */ (id)\n      // @ts-ignore\n      return new this(share.id, share.bits || bits, share.data || data)\n    }\n\n    return new this(id || 0, bits || 0, data)\n  }\n\n  /**\n   * `Share` class constructor.\n   * @param {string|number} [id]\n   * @param {string|number} [bits]\n   * @param {?string} [data]\n   */\n  constructor (id = 0, bits = 0, data = null) {\n    this.id = typeof id === 'number' ? id : parseInt(id, 16)\n    this.bits = typeof bits === 'number' ? bits : parseInt(bits, 36)\n    this.data = typeof data === 'string' ? data : ''\n  }\n}\n\n/**\n * Parsed `input` string or buffer into a `Share` object.\n * @param {string|BufferLike} input\n * @return {Share}\n */\nexport function parse (input) {\n  const share = new Share()\n  const string = isBufferLike(input)\n    ? Buffer.from(input).toString('hex')\n    : input\n\n  const normalized = string[0] === '0'\n    ? string.slice(1)\n    : string\n\n  // bit count is in base36\n  share.bits = parseInt(normalized.slice(0, 1), 36)\n  const idLength = MAX_BITS.toString(16).length\n  const regex = `^([a-kA-K3-9]{1})([a-fA-F0-9]{${idLength}})([a-fA-F0-9]+)$`\n  const matches = new RegExp(regex).exec(normalized)\n\n  if (matches && matches.length) {\n    share.id = parseInt(matches[2], 16)\n    share.data = matches[3]\n  }\n\n  return share\n}\n\n/**\n * Computes the lagrange interoplation aof `x` for node points `p`\n * @param {number} x\n * @param {number[][]} p\n * @return {number}\n */\nexport function lagrange (x, p) {\n  const n = MAX_SHARES\n  let product = 0\n  let sum = 0\n\n  for (let i = 0; i < p[0].length; ++i) {\n    if (p[1][i]) {\n      product = logs[p[1][i]]\n\n      for (let j = 0; j < p[0].length; ++j) {\n        // m != j\n        if (i !== j) {\n          if (x === p[0][j]) {\n            product = -1\n            break\n          }\n\n          const a = logs[x ^ p[0][j]] - logs[p[0][i] ^ p[0][j]]\n          product = (product + a + n) % n\n        }\n      }\n\n      sum = -1 === sum ? sum : sum ^ exps[product]\n    }\n  }\n\n  return sum\n}\n\n/**\n * Reconstruct a secret from a distinct set of shares.\n * @public\n * @param {string[]|BufferLike[]} shares\n * @return {Buffer}\n */\nexport function combine (shares) {\n  const chunks = []\n  const x = []\n  const y = []\n  const t = shares.length\n\n  for (let i = 0; i < t; ++i) {\n    const share = parse(shares[i])\n\n    // @ts-ignore\n    if (x.indexOf(share.id) === -1) {\n      // @ts-ignore\n      x.push(share.id)\n\n      const bin = codec.bin(share.data, 16)\n      const parts = codec.split(bin, 0, 2)\n\n      for (let j = 0; j < parts.length; ++j) {\n        if (!y[j]) {\n          // @ts-ignore\n          y[j] = []\n        }\n\n        // @ts-ignore\n        y[j][x.length - 1] = parts[j]\n      }\n    }\n  }\n\n  for (let i = 0; i < y.length; ++i) {\n    const p = lagrange(0, [x, y[i]])\n    const padded = codec.pad(p.toString(2))\n    // @ts-ignore\n    chunks.unshift(padded)\n  }\n\n  const string = chunks.join('')\n  const bin = string.slice(1 + string.indexOf('1')) // >= 0\n  const hex = codec.hex(bin, BIN_ENCODING)\n  const value = codec.decode(hex)\n\n  return Buffer.from(value)\n}\n\nexport default combine\n", "import { BIN_ENCODING, BIT_PADDING, MAX_SHARES, } from './constants.js'\nimport { exps, logs } from './table.js'\nimport Buffer from './buffer.js'\nimport codec from './codec.js'\n\n/**\n * @typedef {import('./buffer.js').BufferLike} BufferLike\n */\n\n/**\n * @typedef {{ x: number, y: number }} Point\n * @typedef {{\n *   random: function(number): Buffer,\n *   threshold: number,\n *   shares: number\n * }} ComputePointsOptions\n */\n\n/**\n * @typedef {{\n *   random?: function(number): Buffer,\n *   threshold: number,\n *   shares: number\n * }} SplitOptions\n */\n\n// n = MAX_SHARES\n// x = 0 ... n\n// y = n ... 2n\nconst scratch = new Array(2 * MAX_SHARES)\n\n/**\n * Performs polynomial evaluation using the Horner Method for a given `x` term\n * and a setup of polynomial `a`\n * @param {number} x\n * @param {number[]} a\n * @return {number}\n */\nexport function horner (x, a) {\n  const n = MAX_SHARES\n  const t = a.length - 1\n  let b = 0\n\n  for (let i = t; i >= 0; --i) {\n    b = 0 === b ? a[i] : exps[(logs[x] + logs[b]) % n] ^ a[i]\n  }\n\n  return b\n}\n\n/**\n * Generates variable terms for a polynomial\n * @param {number} a0\n * @param {ComputePointsOptions} options\n * @return {Point[]}\n */\nexport function computePoints (a0, options) {\n  const prng = options.random\n  const a = [ a0 ] // p(0) = a0 = secret\n  const p = []\n  const t = options.threshold\n  const n = options.shares\n\n  for (let i = 1; i < t; ++i) {\n    a[i] = parseInt(prng(1).toString('hex'), 16)\n  }\n\n  for (let i = 1; i < 1 + n; ++i) {\n    // @ts-ignore\n    p[i - 1] = {\n      x: i,\n      y: horner(i, a)\n    }\n  }\n\n  return p\n}\n\n/**\n * Split a secret into a set of distinct shares with a configured threshold\n * of shares needed for construction.\n * @public\n * @param {string|BufferLike} input\n * @param {SplitOptions} options\n * @returns {Array<Buffer>}\n * @throws TypeError\n * @throws RangeError\n */\nexport function split (input, options) {\n  if (!input) {\n    throw new TypeError('An input secret must be provided')\n  }\n\n  const secret = Buffer.from(input)\n\n  if (secret.byteLength === 0) {\n    throw new TypeError('Secret cannot be empty')\n  }\n\n  if (!options || typeof options !== 'object') {\n    throw new TypeError('Expecting options to be an object.')\n  }\n\n  if ('shares' in options && typeof options.shares !== 'number') {\n    throw new TypeError('Expecting shares to be a number.')\n  }\n\n  if ('threshold' in options && typeof options.threshold !== 'number') {\n    throw new TypeError('Expecting threshold to be a number.')\n  }\n\n  if (\n    !Number.isFinite(options.shares) ||\n    !Number.isInteger(options.shares) ||\n    !Number.isSafeInteger(options.shares)\n  ) {\n    throw new RangeError('Expecting shares to be a positive integer')\n  }\n\n  if (\n    !Number.isFinite(options.threshold) ||\n    !Number.isInteger(options.threshold) ||\n    !Number.isSafeInteger(options.threshold)\n  ) {\n    throw new RangeError('Expecting threshold to be a positive integer')\n  }\n\n  if (options.shares <= 0 || options.shares > MAX_SHARES) {\n    throw new RangeError(`Shares must be 0 < shares <= ${MAX_SHARES}.`)\n  }\n\n  if (options.threshold <= 0 || options.threshold > options.shares) {\n    throw new RangeError(`Threshold must be 0 < threshold <= ${options.shares}.`)\n  }\n\n  options = { ...options }\n\n  if (!('random' in options)) {\n    options.random = Buffer.random\n  }\n\n  if (typeof options.random !== 'function') {\n    throw new TypeError('Expecting random to be a function')\n  }\n\n  const hex = codec.hex(secret)\n  const bin = codec.bin(hex, 16)\n  // prepend 1 to get extra padding, we'll account for this later\n  const parts = codec.split('1' + bin, BIT_PADDING, 2)\n\n  for (let i = 0; i < parts.length; ++i) {\n    const p = computePoints(parts[i], {\n      shares: options.shares,\n      threshold: options.threshold,\n      random: options.random\n    })\n\n    for (let j = 0; j < options.shares; ++j) {\n\n      if (!scratch[j]) {\n        // @ts-ignore\n        scratch[j] = p[j].x.toString(16)\n      }\n\n      // @ts-ignore\n      const z = p[j].y.toString(2)\n      const y = scratch[j + MAX_SHARES] || ''\n\n      // y[j] = p[j][y] + y[j]\n      scratch[j + MAX_SHARES] = codec.pad(z) + y\n    }\n  }\n\n  for (let i = 0; i < options.shares; ++i) {\n    const x = scratch[i]\n    const y = codec.hex(scratch[i + MAX_SHARES], BIN_ENCODING)\n    scratch[i] = codec.encode(x, y)\n    scratch[i] = Buffer.from('0' + scratch[i], 'hex')\n  }\n\n  const result = scratch.slice(0, options.shares)\n  scratch.fill(0)\n  return result\n}\n\nexport default split\n", "import constants from './constants.js'\nimport combine from './combine.js'\nimport Buffer from './buffer.js'\nimport split from './split.js'\n\nexport const VERSION = '2'\nexport { Buffer, combine, constants, split }\nexport default { Buffer, combine, constants, split }\n"],
  "mappings": "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",
  "names": ["prototype", "byteLength", "bin", "hex", "split", "hex", "bin"]
}
